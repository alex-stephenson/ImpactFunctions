return(cleaning_log_amended)
}
loa <- create_full_loa(kobo_survey = survey,
data = clean_data,
sm_sep = "/",
group_vars = c('admin_1')) %>%
filter(! analysis_var %in% c('_uuid', 'hc_hex_id', 'weight', 'Hex_ID', 'enum_id'))
#' Automatically produce a LOA from a Kobo Tool and survey data
#'
#' This function produces a LOA to be used in the production of results tables from
#' `analysistools::create_analysis`.
#' The function creates a LOA based on the Kobo server tool, inferring the analysis_type from
#' the 'type' column in the tool.
#' It adds to this by looking at any data in the survey that is not present in the tool
#' and attempts to guess based on the class of the column.
#'
#' @param kobo_survey Your Kobo survey. Must have columns type and name. Leave blank if you want the LOA from the dataframe instead
#' @param data Your survey data, for capturing composite indicators not from your tool. Leave blank if only tool is required.
#' @param level confidence interval, defaults to 0.95
#' @param group_vars disaggregation variables, to be provided as a string. E.g. c('admin1', 'admin2). Leave blank for no disaggregation.
#' @param sm_sep defaults to '/'
#' @param print_class_type TRUE/FALSE whether to output any analysis_type assumed based on the data type.
#'
#' @return A dataframe containing
#' \describe{
#'   \item{analysis_var}{name of the indicator}
#'   \item{analysis_type}{analysis to perform}
#'   \item{level}{Confidence Interval}
#'   \item{group_var}{indicators to disaggregate by}
#' }
#'
#' @examples
#' create_loa(kobo_survey = tool, data = clean_data, group_vars = c('admin_1', 'admin2'))
#'
#' @importFrom dplyr select mutate case_when rename filter cross_join bind_rows
#' @importFrom stringr str_detect fixed
#' @importFrom tidyr separate_longer_delim
#' @importFrom tibble tibble
#' @importFrom purrr walk2
#' @importFrom cleaningtools auto_detect_sm_parents
#' @export
create_full_loa <- function(kobo_survey = NULL,
data = NULL,
level = 0.95,
group_vars = NULL,
sm_sep = "/",
print_class_type = TRUE) {
# Infer tool/data usage automatically
if (is.null(kobo_survey)) {
use_tool <- FALSE
} else {
use_tool <- TRUE
}
if (is.null(data)) {
use_data <- FALSE
} else {
use_data <- TRUE
}
if (isFALSE(use_tool) & isFALSE(use_data)) {
stop("Must provide either tool or data")
}
if (!is.null(group_vars) && all(!is.na(group_vars))) {
if (!all(group_vars %in% names(data))) {
stop("One or more group_vars are not present in data")
}
}
if (isTRUE(use_tool)) {
stopifnot(all(c("type", "name") %in% names(kobo_survey)))
tool_loa <- kobo_survey %>%
select(type, name) %>%
mutate(
analysis_type = case_when(
type == "integer" ~ "mean:median",
str_detect(type, "select_one") ~ "prop_select_one",
str_detect(type, "select_mult") ~ "prop_select_multiple"
),
level = 0.95
) %>%
separate_longer_delim(analysis_type, ":") %>%
rename(analysis_var = name) %>%
select(-type) %>%
filter(!is.na(analysis_type))
}
if (isTRUE(use_data)) {
survey_metatdata <- c(
'_index', '_id', '__version__', 'instanceID', '_xform_id_string',
'uuid', '_uuid', 'rootUuid', '_status', '_submission_time', '_validation_status',
'_submitted_by', '_attachments', 'weights', 'weight'
)
sm_q <- cleaningtools::auto_detect_sm_parents(data, sm_separator = sm_sep)
inferred <- vapply(names(data), function(colname) {
if (colname %in% sm_q) {
return("prop_select_multiple")
} else if (is.character(data[[colname]])) {
return("prop_select_one")
} else if (is.numeric(data[[colname]])) {
return("median:mean")
} else {
return(NA_character_)
}
}, character(1), USE.NAMES = TRUE)
custom_loa <- tibble(
analysis_var = names(inferred),
analysis_type = as.character(inferred)
) %>%
mutate(level = !!level) %>%
filter(!analysis_var %in% survey_metatdata)
if (isTRUE(use_tool)) {
custom_loa <- custom_loa %>%
filter(!str_detect(analysis_var, fixed(sm_sep))) %>%
filter(!analysis_var %in% kobo_survey$name)
}
if (isFALSE(use_tool)) {
custom_loa <- custom_loa %>%
filter(!str_detect(analysis_var, fixed(sm_sep)))
}
if (isTRUE(print_class_type)) {
message("Indicators inferred from data, not from tool, include...:")
walk2(custom_loa$analysis_var, custom_loa$analysis_type, function(analysis_var, analysis_type) {
if (is.na(analysis_type)) {
message(paste0(analysis_var, " is not type select or numeric, removed"))
} else if (analysis_type == "prop_select_one") {
message(paste0(analysis_var, " classified as prop_select_one"))
} else {
message(paste0(analysis_var, " is classified as mean / median"))
}
})
}
}
if (is.null(group_vars) || all(is.na(group_vars))) {
group_vars_NA <- data.frame(group_var = NA)
} else {
group_vars_NA <- data.frame(group_var = c(NA, group_vars))
}
if (isTRUE(use_tool) & isTRUE(use_data)) {
full_loa <- custom_loa %>%
separate_longer_delim(analysis_type, ":") %>%
filter(!is.na(analysis_type)) %>%
bind_rows(., tool_loa) %>%
cross_join(group_vars_NA) %>%
filter(group_var != analysis_var | is.na(group_var))
return(full_loa)
}
if (isTRUE(use_tool) & isFALSE(use_data)) {
output_loa <- tool_loa %>%
filter(!is.na(analysis_type)) %>%
separate_longer_delim(analysis_type, ":") %>%
cross_join(group_vars_NA) %>%
filter(group_var != analysis_var | is.na(group_var))
return(output_loa)
}
if (isFALSE(use_tool) & isTRUE(use_data)) {
output_loa <- custom_loa %>%
filter(!is.na(analysis_type)) %>%
separate_longer_delim(analysis_type, ":") %>%
cross_join(group_vars_NA) %>%
filter(group_var != analysis_var | is.na(group_var))
return(output_loa)
}
}
loa <- create_full_loa(kobo_survey = survey,
data = clean_data,
sm_sep = "/",
group_vars = c('admin_1')) %>%
filter(! analysis_var %in% c('_uuid', 'hc_hex_id', 'weight', 'Hex_ID', 'enum_id'))
loa
RT_output <- multi_results_table_output(
data = clean_data,
weights = TRUE,
weights_col = "weight",
loa = loa,
strata = "unit_of_analysis",
sm_seperator = "/",
questions = survey,
choices = choices,
value_columns = c("stat", "n")
)
ImpactFunctions::create_xlsx_cleaning_log
tool = survey
choices = choices
other_text_questions <- tool %>%
dplyr::filter(type == "text", stringr::str_detect(relevant, "(?i)'other'\\)\\s*$")) %>%
dplyr::mutate(
parent_question = stringr::str_extract(relevant, "\\{([A-Za-z0-9_]+)\\}") %>%
stringr::str_remove_all("\\{|\\}")
)
other_text_questions
other_text_questions
parent_questions <- tool %>%
dplyr::filter(stringr::str_detect(type, "select")) %>%
dplyr::mutate(list_name = stringr::str_split_i(type, " ", 2)) %>%
dplyr::filter(name %in% other_text_questions$parent_question)
parent_questions
# Step 3: Filter choices to only relevant list_names
relevant_choices <- choices %>%
dplyr::filter(list_name %in% parent_questions$list_name)
# Step 4: Combine everything into wide format: other question ~ its 'other' answer options
questions_and_answers <- parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
) %>%
dplyr::left_join(
choices %>% dplyr::rename(answer_name = name),
by = "list_name",
relationship = "many-to-many"
) %>%
dplyr::filter(answer_name != 'other') %>%
dplyr::group_by(other_question) %>%
dplyr::summarise(
choices = paste(answer_name, collapse = ";\n"),
.groups = "drop"
)
parent_questions
parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
)
questions_and_answers <- parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
) %>%
dplyr::left_join(
choices %>% dplyr::rename(answer_name = name),
by = "list_name",
relationship = "many-to-many"
)
View(questions_and_answers)
questions_and_answers <- parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
) %>%
dplyr::left_join(
choices %>% dplyr::rename(answer_name = name),
by = "list_name",
relationship = "many-to-many"
) %>%
dplyr::filter(answer_name != 'other') %>%
dplyr::group_by(other_question) %>%
dplyr::summarise(
choices = paste(answer_name, collapse = ";\n"),
.groups = "drop"
)
View(questions_and_answers)
devtools::document()
devtools::document()
devtools::document()
remove.packages("ImpactFunctions")
devtools::install_github("alex-stephenson/ImpactFunctions")
raw_data
survey <- readxl::read_excel("../testing/data/REACH_SOM2503_MSNA_2025_IPC_Clean Dataset_revised_v2.xlsx", sheet = "survey")
choices <- readxl::read_excel("../testing/data/REACH_SOM2503_MSNA_2025_IPC_Clean Dataset_revised_v2.xlsx", sheet = "choices")
clean_data <- readxl::read_excel("../testing/data/REACH_SOM2503_MSNA_2025_IPC_Clean Dataset_revised_v2.xlsx", sheet = "hh clean data")
raw_data <- readxl::read_excel("../testing/data/REACH_SOM2503_MSNA_2025_IPC_Clean Dataset_revised_v2.xlsx", sheet = "hh raw data")
cleaning_logs <- readxl::read_excel("../testing/data/REACH_SOM2503_MSNA_2025_IPC_Clean Dataset_revised_v2.xlsx", sheet = "hh cleaning log")
raw_data %>%
cleaningtools::review_others(uuid = "_uuid")
library(tidyverse)
library(cleaningtools)
raw_data %>%
cleaningtools::review_others(uuid = "_uuid")
?review_others
raw_data %>%
cleaningtools::review_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
other_clog <_ raw_data %>%
other_clog <- raw_data %>%
cleaningtools::review_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
other_clog
other_clog <- raw_data %>%
cleaningtools::review_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
w_data %>%
check_pii(uuid_column = "_uuid")
raw_data %>%
check_pii(uuid_column = "_uuid")
other_clog <- raw_data %>%
cleaningtools::review_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
survey <- survey %>% filter(name %in% colnames(raw_data))
other_clog <- raw_data %>%
cleaningtools::review_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
other_clog
View(other_clog)
review_others
other_clog <- raw_data %>%
cleaningtools::check_others(uuid = "_uuid", kobo_survey = survey, sm_separator = "/")
?check_others
other_clog <- raw_data %>%
cleaningtools::check_others(uuid = "_uuid")
names(cleaningtools::raw_data |>
dplyr::select(ends_with("other")) |>
dplyr::select(-contains("."))
)
cols_to_check <- raw_data %>%
select(ends_with('other')) %>%
select(-contains('/'))
cols_to_check
View(cols_to_check)
cols_to_check <- names(raw_data %>%
select(ends_with('other')) %>%
select(-contains('/')))
other_clog <- raw_data %>%
cleaningtools::check_others(uuid = "_uuid",
columns_to_check = cols_to_check)
cols_to_check
raw_data %>%
select(ends_with('other')) %>%
select(-contains('/'))
raw_data %>%
select(ends_with('other')) %>%
select(-contains('/')) %>% View()
cols_to_check <- questions %>%
filter(type == "text",
str_detect(name, "other")) %>%
pull(name)
cols_to_check <- survey %>%
filter(type == "text",
str_detect(name, "other")) %>%
pull(name)
cols_to_check
other_clog <- raw_data %>%
cleaningtools::check_others(uuid = "_uuid",
columns_to_check = cols_to_check)
other_clog
ImpactFunctions::create_xlsx_cleaning_log
?ImpactFunctions::create_xlsx_cleaning_log
other_clog %>%
ImpactFunctions::create_xlsx_cleaning_log(use_others = T, output_path = "test_clog.xlsx")
other_clog <- raw_data %>%
cleaningtools::check_others(uuid = "_uuid",
columns_to_check = cols_to_check) %>%
create_combined_log()
other_clog
other_clog %>%
ImpactFunctions::create_xlsx_cleaning_log(use_others = T, output_path = "test_clog.xlsx")
other_clog %>%
ImpactFunctions::create_xlsx_cleaning_log(use_others = T,
kobo_survey = survey,
kobo_choices = choices,
output_path = "test_clog.xlsx")
ImpactFunctions
tool <- survey
choices <- choices
create_other_df <- function(tool, choices) {
# Step 1: Identify relevant 'other' text questions and their parent question names
other_text_questions <- tool %>%
dplyr::filter(type == "text", stringr::str_detect(relevant, "(?i)'other'\\)\\s*$")) %>%
dplyr::mutate(
parent_question = stringr::str_extract(relevant, "\\{([A-Za-z0-9_]+)\\}") %>%
stringr::str_remove_all("\\{|\\}")
)
# Step 2: Get list names for the parent questions
parent_questions <- tool %>%
dplyr::filter(stringr::str_detect(type, "select")) %>%
dplyr::mutate(list_name = stringr::str_split_i(type, " ", 2)) %>%
dplyr::filter(name %in% other_text_questions$parent_question)
# Step 3: Filter choices to only relevant list_names
relevant_choices <- choices %>%
dplyr::filter(list_name %in% parent_questions$list_name)
# Step 4: Combine everything into wide format: other question ~ its 'other' answer options
questions_and_answers <- parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
) %>%
dplyr::left_join(
choices %>% dplyr::rename(answer_name = name),
by = "list_name",
relationship = "many-to-many"
) %>%
dplyr::filter(! answer_name %in%  c('other', 'Other')) %>%
dplyr::group_by(other_question) %>%
dplyr::summarise(
choices = paste(answer_name, collapse = ";\n"),
.groups = "drop"
)
if (nrow(questions_and_answers) == 0) {
stop("No 'other' questions with matching choices found.")
}
return(questions_and_answers)
}
create_other_df
other_text_questions <- tool %>%
dplyr::filter(type == "text", stringr::str_detect(relevant, "(?i)'other'\\)\\s*$")) %>%
dplyr::mutate(
parent_question = stringr::str_extract(relevant, "\\{([A-Za-z0-9_]+)\\}") %>%
stringr::str_remove_all("\\{|\\}")
)
# Step 2: Get list names for the parent questions
parent_questions <- tool %>%
dplyr::filter(stringr::str_detect(type, "select")) %>%
dplyr::mutate(list_name = stringr::str_split_i(type, " ", 2)) %>%
dplyr::filter(name %in% other_text_questions$parent_question)
# Step 3: Filter choices to only relevant list_names
relevant_choices <- choices %>%
dplyr::filter(list_name %in% parent_questions$list_name)
# Step 4: Combine everything into wide format: other question ~ its 'other' answer options
questions_and_answers <- parent_questions %>%
# parent_questions has: name (parent) and list_name
dplyr::left_join(
other_text_questions %>%
dplyr::select(other_question = name, parent_question),
by = c("name" = "parent_question")
) %>%
dplyr::left_join(
choices %>% dplyr::rename(answer_name = name),
by = "list_name",
relationship = "many-to-many"
) %>%
dplyr::filter(! answer_name %in%  c('other', 'Other')) %>%
dplyr::group_by(other_question) %>%
dplyr::summarise(
choices = paste(answer_name, collapse = ";\n"),
.groups = "drop"
)
if (nrow(questions_and_answers) == 0) {
stop("No 'other' questions with matching choices found.")
}
questions_and_answers
others <- T
new_lists <- list(
c("change_type_validation", "change_response;\nblank_response;\nremove_survey;\nno_action"),
c("binaries_sm_options_lgl", "FALSE;\nTRUE"),
c("binaries_sm_options_num", "0;\n1")
# c("_duplicates_","-- keep the survey --;\n-- delete the survey --"),
# c("_action_","-- confirm --;\n-- update --;\n-- delete --")
) %>%
do.call(rbind, .) %>%
as.data.frame() %>%
stats::setNames(c("name", "choices"))
choicelist <- new_lists %>%
dplyr::bind_rows(create_formatted_choices(choices, tool) %>%
dplyr::select(name, choices))
if (others) {
extra = create_other_df(tool = tool, choices = choices)
choicelist <- dplyr::bind_rows(
choicelist,
extra %>% dplyr::rename(name = other_question)
)
}
choice_validation <- choicelist %>%
unique() %>%
data.table::transpose() %>%
stats::setNames(.[1, ]) %>%
dplyr::slice(-1) %>%
dplyr::mutate_all(~ stringr::str_split(., ";\n"))
nrow_validation <- lapply(choice_validation, function(x) length(x[[1]])) %>%
unlist() %>%
max()
data.val <- data.frame(matrix(NA, nrow = nrow_validation, ncol = 0))
for (c in colnames(choice_validation)) {
data.val <- data.val %>%
dplyr::mutate(!!rlang::sym(c) := c(unlist(choice_validation[[c]]), rep(NA, nrow_validation - length(choice_validation[[c]][[1]]))))
}
data.val
View(data.val)
extra = create_other_df(tool = tool, choices = choices)
source("C:/Users/alex.stephenson/Desktop/R/ImpactFunctions/R/create_xlsx_cleaning_log.R", echo = TRUE)
choicelist
View(choicelist)
choice_validation <- choicelist %>%
unique() %>%
data.table::transpose() %>%
stats::setNames(.[1, ]) %>%
dplyr::slice(-1) %>%
dplyr::mutate_all(~ stringr::str_split(., ";\n"))
View(choice_validation)
View(data.val)
create_validation_list(kobo_choices,
kobo_survey |> dplyr::filter(!stringr::str_detect(pattern = "(begin|end)(\\s+|_)group", type)),
others = use_others)
kobo_choices <- survey
kobo_choices <- choices
kobo_survey <- survey
create_validation_list(kobo_choices,
kobo_survey |> dplyr::filter(!stringr::str_detect(pattern = "(begin|end)(\\s+|_)group", type)),
others = use_others)
use_others <- T
create_validation_list(kobo_choices,
kobo_survey |> dplyr::filter(!stringr::str_detect(pattern = "(begin|end)(\\s+|_)group", type)),
others = use_others)
data.val <- create_validation_list(kobo_choices,
kobo_survey |> dplyr::filter(!stringr::str_detect(pattern = "(begin|end)(\\s+|_)group", type)),
others = use_others)
View(data.val)
other_clog %>%
ImpactFunctions::create_xlsx_cleaning_log(use_others = T,
use_dropdown = T,
kobo_survey = survey,
kobo_choices = choices,
sm_dropdown_type = "numerical",
output_path = "test_clog.xlsx")
other_clog %>%
ImpactFunctions::create_xlsx_cleaning_log(use_others = T,
use_dropdown = T,
kobo_survey = survey,
kobo_choices = choices,
sm_dropdown_type = "numerical",
output_path = "test_clog.xlsx")
analysistools::create_loa
choose.files()
