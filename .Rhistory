sample_survey_data_path_sheet = NULL,
file_path = r"(C:\Users\alex.stephenson\Downloads\DSA_clogs/combined_clog.xlsx)",
file_path_sheet = "Sheet1",
output_dir = r"(C:\Users\alex.stephenson\Downloads\DSA_clogs)",
output_as_excel = TRUE,
output_as_list = TRUE
)
input_dir <- r"(C:\Users\alex.stephenson\Downloads\DSA_clogs)"
output_dir <- r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\01CLeaning scripts\04_data_cleaning\hassan - Clogs\Finished_Clogs\clog_review)"  # Replace with the desired output directory
all_outputs <- list()
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)
}
# List all Excel files in the input directory
excel_files <- list.files(input_dir, pattern = "\\.xlsx$", full.names = TRUE)
excel_files
for (file_path in excel_files) {
tryCatch({
checks_output <- process_cleaning_log(
tool_path = r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 02_Research\01_REACH\2024_25\03_DDSU\SOM2204 _DSA VIII 2025\02_Data_Collection\01_Tool/REACH_2024_SOM_DSA_Survey_Tool_VIII.xlsx)",  # Replace with the path to the tool file
survey_sheet = "survey",
choice_sheet = "choices",
sample_survey_data_path = r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 02_Research\01_REACH\2024_25\03_DDSU\SOM2204 _DSA VIII 2025\03_Data_Analysis\DSA_VIII_Scripts\output/DSA_2024_REACH_SOM_Processed_Data_2024-11-28.xlsx)",  # Replace with the sample survey data path
sample_survey_data_path_sheet = NULL,
file_path = file_path,
output_dir = output_dir,
output_as_excel = FALSE,
output_as_list = TRUE
)
}, error = function(e) {
cat("Error processing file:", file_path, "\nError message:", e$message, "\n")
})
#all_outputs <- append(all_outputs, list(checks_output))
all_outputs[[basename(file_path)]] <- checks_output
}
# Initialize tool_answer_check if needed
tool_answer_check <- NULL
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value = as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value = as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]]$check_id = as.character(all_outputs[[i]][["tool_answer_check"]]$check_id)
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value = as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]]$check_id = as.character(all_outputs[[i]][["tool_answer_check"]]$check_id)
all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment = as.character(all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment)
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value <- as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]]$check_id <- as.character(all_outputs[[i]][["tool_answer_check"]]$check_id)
all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment <- as.character(all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment)
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment
all_outputs[[i]][["tool_answer_check"]]
all_outputs[[i]][["tool_answer_check"]] %>% View()
# Initialize tool_answer_check if needed
tool_answer_check <- NULL
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value <- as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]]$check_id <- as.character(all_outputs[[i]][["tool_answer_check"]]$check_id)
all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment <- NULL
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
tool_answer_check
View(tool_answer_check)
View(all_clogs)
View(all_outputs)
input_dir <- r"(C:\Users\alex.stephenson\Downloads\DSA_clogs)"
output_dir <- r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\01CLeaning scripts\04_data_cleaning\hassan - Clogs\Finished_Clogs\clog_review)"  # Replace with the desired output directory
all_outputs <- list()
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)
}
# List all Excel files in the input directory
excel_files <- list.files(input_dir, pattern = "cleaning_log\\.xlsx$", full.names = TRUE)
excel_files
# List all Excel files in the input directory
excel_files <- list.files(input_dir, pattern = "cleaning_log\\.", full.names = TRUE)
# Define the directories
input_dir <- r"(C:\Users\alex.stephenson\Downloads\DSA_clogs)"
output_dir <- r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\01CLeaning scripts\04_data_cleaning\hassan - Clogs\Finished_Clogs\clog_review)"  # Replace with the desired output directory
all_outputs <- list()
if (!dir.exists(output_dir)) {
dir.create(output_dir, recursive = TRUE)
}
# List all Excel files in the input directory
excel_files <- list.files(input_dir, pattern = "\\.xlsx$", full.names = TRUE)
# Iterate over each Excel file and process it
for (file_path in excel_files) {
tryCatch({
checks_output <- process_cleaning_log(
tool_path = r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 02_Research\01_REACH\2024_25\03_DDSU\SOM2204 _DSA VIII 2025\02_Data_Collection\01_Tool/REACH_2024_SOM_DSA_Survey_Tool_VIII.xlsx)",  # Replace with the path to the tool file
survey_sheet = "survey",
choice_sheet = "choices",
sample_survey_data_path = r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 02_Research\01_REACH\2024_25\03_DDSU\SOM2204 _DSA VIII 2025\03_Data_Analysis\DSA_VIII_Scripts\output/DSA_2024_REACH_SOM_Processed_Data_2024-11-28.xlsx)",  # Replace with the sample survey data path
sample_survey_data_path_sheet = NULL,
file_path = file_path,
output_dir = output_dir,
output_as_excel = FALSE,
output_as_list = TRUE
)
}, error = function(e) {
cat("Error processing file:", file_path, "\nError message:", e$message, "\n")
})
#all_outputs <- append(all_outputs, list(checks_output))
all_outputs[[basename(file_path)]] <- checks_output
}
# Initialize tool_answer_check if needed
tool_answer_check <- NULL
for (i in seq_along(all_outputs)) {  # safer loop
# Add rows to tool_answer_check
all_outputs[[i]][["tool_answer_check"]]$new_value <- as.character(all_outputs[[i]][["tool_answer_check"]]$new_value)
all_outputs[[i]][["tool_answer_check"]]$check_id <- as.character(all_outputs[[i]][["tool_answer_check"]]$check_id)
all_outputs[[i]][["tool_answer_check"]]$Field_SFO_Comment <- NULL
all_outputs[[i]][["tool_answer_check"]] <- all_outputs[[i]][["tool_answer_check"]] %>%
mutate(file_name = names(all_outputs)[i])
tool_answer_check <- bind_rows(tool_answer_check, all_outputs[[i]][["tool_answer_check"]])
}
tool_answer_check
writexl::write_xlsx(tool_answer_check, r"(C:\Users\alex.stephenson\Downloads\tool_answer_check.xlsx)")
all_clogs
normalize_shelter_perc <- function(shelter_type_perc) {
shelter_sum <- sum(shelter_type_perc)
if (shelter_sum > 0 & shelter_sum != 100) {
return(round(((shelter_type_perc / shelter_sum) * 100), digits = 0))
}
return(shelter_type_perc)
}
all_clogs$question %>% distinct()
distict(all_clogs, question)
distinct(all_clogs, question)
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift'))
group_by(uuid)
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid)
normalize_shelter_perc <- function(shelter_type_perc) {
shelter_sum <- sum(shelter_type_perc)
if (shelter_sum > 0 & shelter_sum != 100) {
return(round(((shelter_type_perc / shelter_sum) * 100), digits = 0))
}
return(shelter_type_perc)
}
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(new_value)) %>% select(new_value)
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(13)) %>% select(new_value)
data <- c(100, 200, 50, 50)
normalize_shelter_perc(data)
normalize_shelter_perc <- function(shelter_type_perc) {
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
shelter_sum <- sum(shelter_type_perc)
if (shelter_sum > 0 & shelter_sum != 100) {
return(round(((shelter_type_perc / shelter_sum) * 100), digits = 0))
}
return(shelter_type_perc)
}
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(new_value)) %>% select(new_value)
all_clogs %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>% summarise(n = sum(new_value))
all_clogs %>%
mutate(new_value = as.numeric(new_value)) %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(new_value)) %>% select(new_value)
test <- all_clogs %>%
mutate(new_value = as.numeric(new_value)) %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(new_value)) %>% select(new_value)
test <- all_clogs %>%
mutate(new_value = as.numeric(new_value)) %>%
filter(question %in% c('buul', 'unfinished', 'other_sleeping', 'Tent', 'sleeping_open', 'make_shift')) %>%
group_by(uuid) %>%
mutate(new_value = normalize_shelter_perc(new_value))
test %>%
group_by(uuid) %>%
summarise(n = sum(new_value))
test %>%
group_by(uuid) %>%
summarise(n = sum(new_value)) %>%
filter(n != 100)
test %>%
group_by(uuid) %>%
summarise(n = sum(new_value)) %>%
filter(n != 100) %>%
arrange(desc(n))
devtools::document()
devtools::document()
?document
document
devtools::document
devtools::document()
library(ImpactFunctions)
?clog_check
?clog_check()
library(ImpactFunctions)
?clog_check()#
?devtools::load_all
devtools::load_all()
devtools::load_all()
?ImpactFunctions::process_cleaning_log()
devtools::document()
devtools::load_all()
?ImpactFunctions::process_cleaning_log()
?ImpactFunctions::review_cleaning_log()
devtools::load_all()
?ImpactFunctions::review_cleaning_log()
devtools::document()
devtools::load_all()
?ImpactFunctions::review_cleaning_log()
devtools::install_github("alex_stephenson/ImpactFunctions")
devtools::install_github("alex-stephenson/ImpactFunctions")
remove.packages("ImpactFunctions")
devtools::install_github("alex-stephenson/ImpactFunctions")
devtools::install_github("alex-stephenson/ImpactFunctions")
?ImpactFunctions::review_cleaning_log
rm(list = ls())
combined_clogs <- readxl::read_excel(r"(C:\Users\alex.stephenson\Downloads/combined_corrected_clogs_2025-01-06.xlsx)", sheet = "cleaning_log")
combined_clogs <- combined_clogs %>%
distinct(uuid,old_value, question,change_type,
new_value, enum_code, .keep_all = T)
library(tidyverse)
combined_clogs <- readxl::read_excel(r"(C:\Users\alex.stephenson\Downloads/combined_corrected_clogs_2025-01-06.xlsx)", sheet = "cleaning_log")
combined_clogs <- combined_clogs %>%
distinct(uuid,old_value, question,change_type,
new_value, enum_code, .keep_all = T)
change_response <- combined_clogs %>%
filter(change_type == "change_response")
change_response <- change_response %>%
mutate(question_stem = str_extract(question, "^[^/]+"))
data <- change_response
update_parent_values <- function(data) {
# Identify the parent rows (those without '/') and child rows (those with '/')
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
# Get the parent rows that have missing child options
missing_children <- data %>%
filter(!is_parent, new_value == "1") %>%
select(uuid, question_stem, child_option) %>%
distinct()
# Ensure the 'child_option' is retained after the join
data_updated <- data %>%
filter(is_parent) %>%
left_join(missing_children, by = c("uuid", "question_stem")) %>%
group_by(uuid, question_stem) %>%
mutate(
# Combine the parent value and missing child options
updated_new_value = paste(
unique(c(str_split(new_value, "\\s+")[[1]], child_option.x, child_option.y)),
collapse = " "
)
) %>%
ungroup()
# Check if the 'updated_new_value' exists and fix the issue by using proper column names
if("updated_new_value" %in% colnames(data_updated)) {
data_final <- data_updated %>%
bind_rows(data %>% filter(!is_parent)) %>%
distinct() %>%
filter(!is.na(uuid) & !is.na(question)) %>%
arrange(uuid, question)
} else {
stop("Error: 'updated_new_value' column is not present in the data.")
}
return(data_final)
}
update_parent_values(change_response)
resolved_data <- update_parent_values(change_response)
resolved_data$updated_new_value
data_final %>%
select(question, check_binding, select_multiple_value = updated_new_value) %>%
filter(!str_detect(question, "/"))
update_parent_values <- function(data) {
# Identify the parent rows (those without '/') and child rows (those with '/')
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
# Get the parent rows that have missing child options
missing_children <- data %>%
filter(!is_parent, new_value == "1") %>%
select(uuid, question_stem, child_option) %>%
distinct()
# Ensure the 'child_option' is retained after the join
data_updated <- data %>%
filter(is_parent) %>%
left_join(missing_children, by = c("uuid", "question_stem")) %>%
group_by(uuid, question_stem) %>%
mutate(
# Combine the parent value and missing child options
updated_new_value = paste(
unique(c(str_split(new_value, "\\s+")[[1]], child_option.x, child_option.y)),
collapse = " "
)
) %>%
ungroup()
# Check if the 'updated_new_value' exists and fix the issue by using proper column names
if("updated_new_value" %in% colnames(data_updated)) {
data_final <- data_updated %>%
bind_rows(data %>% filter(!is_parent)) %>%
distinct() %>%
filter(!is.na(uuid) & !is.na(question)) %>%
arrange(uuid, question)
} else {
stop("Error: 'updated_new_value' column is not present in the data.")
}
resolved_data <- data_final %>%
select(question, check_binding, select_multiple_value = updated_new_value) %>%
filter(!str_detect(question, "/"))
parent_q_correct <- change_response %>%
left_join(resolved_data, by = join_by(question == question, check_binding == check_binding))
combined_new_answers <- parent_q_correct %>%
mutate(new_value = ifelse(is.na(select_multiple_value), new_value, select_multiple_value),
new_value = str_replace_all(new_value, "NA", ""),
new_value = str_squish(new_value)) %>%
distinct()
return(combined_new_answers)
}
change_response <- change_response %>%
mutate(question_stem = str_extract(question, "^[^/]+"))
data <- update_parent_values(change_response)
data
View(data)
change_response$new_value == data$new_value
data <- change_response
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
missing_children <- data %>%
filter(!is_parent, new_value == "1") %>%
select(uuid, question_stem, child_option) %>%
distinct()
missing_children
data_updated <- data %>%
filter(is_parent) %>%
left_join(missing_children, by = c("uuid", "question_stem")) %>%
group_by(uuid, question_stem) %>%
mutate(
# Combine the parent value and missing child options
updated_new_value = paste(
unique(c(str_split(new_value, "\\s+")[[1]], child_option.x, child_option.y)),
collapse = " "
)
) %>%
ungroup()
data_updated
update_parent_values <- function(data, tool_path, survey_sheet = "survey") {
## lets first make sure we're only using select multiple questions
kobo_survey <- tryCatch(read_excel(tool_path, sheet = survey_sheet, .name_repair = "unique_quiet"),
error = function(e) stop("Error reading survey sheet: ", e))
kobo_survey_sm <- kobo_survey %>%
filter(str_detect(type, "multiple")) %>%
pull(name)
data<- data %>%
filter(question %in% kobo_survey_sm,
change_type == "change_response") %>%
mutate(question_stem = str_extract(question, "^[^/]+"))
# Identify the parent rows (those without '/') and child rows (those with '/')
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
# Get the parent rows that have missing child options
missing_children <- data %>%
filter(!is_parent, new_value == "1") %>%
select(uuid, question_stem, child_option) %>%
distinct()
# Ensure the 'child_option' is retained after the join
data_updated <- data %>%
filter(is_parent) %>%
left_join(missing_children, by = c("uuid", "question_stem")) %>%
group_by(uuid, question_stem) %>%
mutate(
# Combine the parent value and missing child options
updated_new_value = paste(
unique(c(str_split(new_value, "\\s+")[[1]], child_option.x, child_option.y)),
collapse = " "
)
) %>%
ungroup()
# Check if the 'updated_new_value' exists and fix the issue by using proper column names
if("updated_new_value" %in% colnames(data_updated)) {
data_final <- data_updated %>%
bind_rows(data %>% filter(!is_parent)) %>%
distinct() %>%
filter(!is.na(uuid) & !is.na(question)) %>%
arrange(uuid, question)
} else {
stop("Error: 'updated_new_value' column is not present in the data.")
}
resolved_data <- data_final %>%
select(question, check_binding, select_multiple_value = updated_new_value) %>%
filter(!str_detect(question, "/"))
parent_q_correct <- change_response %>%
left_join(resolved_data, by = join_by(question == question, check_binding == check_binding))
combined_new_answers <- parent_q_correct %>%
mutate(new_value = ifelse(is.na(select_multiple_value), new_value, select_multiple_value),
new_value = str_replace_all(new_value, "NA", ""),
new_value = str_squish(new_value)) %>%
distinct()
return(combined_new_answers)
}
update_parent_values(data = combined_clogs,
tool_path =  "C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\00_tool\SOM_REACH_HSM_December_2024_Tool_Pilot_ver_AS_EDITS_v2.xlsx"
update_parent_values(data = combined_clogs,
tool_path =  r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\00_tool\SOM_REACH_HSM_December_2024_Tool_Pilot_ver_AS_EDITS_v2.xlsx)"
)
library(readxl)
update_parent_values <- function(data, tool_path, survey_sheet = "survey") {
## lets first make sure we're only using select multiple questions
kobo_survey <- tryCatch(read_excel(tool_path, sheet = survey_sheet, .name_repair = "unique_quiet"),
error = function(e) stop("Error reading survey sheet: ", e))
kobo_survey_sm <- kobo_survey %>%
filter(str_detect(type, "multiple")) %>%
pull(name)
data<- data %>%
filter(question %in% kobo_survey_sm,
change_type == "change_response") %>%
mutate(question_stem = str_extract(question, "^[^/]+"))
# Identify the parent rows (those without '/') and child rows (those with '/')
data <- data %>%
mutate(
is_parent = !str_detect(question, "/"),
child_option = ifelse(!is_parent, str_remove(question, ".*/"), NA)
)
# Get the parent rows that have missing child options
missing_children <- data %>%
filter(!is_parent, new_value == "1") %>%
select(uuid, question_stem, child_option) %>%
distinct()
# Ensure the 'child_option' is retained after the join
data_updated <- data %>%
filter(is_parent) %>%
left_join(missing_children, by = c("uuid", "question_stem")) %>%
group_by(uuid, question_stem) %>%
mutate(
# Combine the parent value and missing child options
updated_new_value = paste(
unique(c(str_split(new_value, "\\s+")[[1]], child_option.x, child_option.y)),
collapse = " "
)
) %>%
ungroup()
# Check if the 'updated_new_value' exists and fix the issue by using proper column names
if("updated_new_value" %in% colnames(data_updated)) {
data_final <- data_updated %>%
bind_rows(data %>% filter(!is_parent)) %>%
distinct() %>%
filter(!is.na(uuid) & !is.na(question)) %>%
arrange(uuid, question)
} else {
stop("Error: 'updated_new_value' column is not present in the data.")
}
resolved_data <- data_final %>%
select(question, check_binding, select_multiple_value = updated_new_value) %>%
filter(!str_detect(question, "/"))
parent_q_correct <- change_response %>%
left_join(resolved_data, by = join_by(question == question, check_binding == check_binding))
combined_new_answers <- parent_q_correct %>%
mutate(new_value = ifelse(is.na(select_multiple_value), new_value, select_multiple_value),
new_value = str_replace_all(new_value, "NA", ""),
new_value = str_squish(new_value)) %>%
distinct()
return(combined_new_answers)
}
update_parent_values(data = combined_clogs,
tool_path =  r"(C:\Users\alex.stephenson\ACTED\IMPACT SOM - 01_REACH\2024_25\01_ISU\SOM1901_HSM\03_Data & Data Analysis\DEC_24\00_tool\SOM_REACH_HSM_December_2024_Tool_Pilot_ver_AS_EDITS_v2.xlsx)"
)
